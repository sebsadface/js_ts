%%%%%%%%%%%%%%%%%%%%% PACKAGE IMPORTS %%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt]{article}
\usepackage{amsmath, amsfonts, amsthm, amssymb}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{fullpage}       
\usepackage{changepage}
\usepackage{hyperref}
\usepackage{blindtext}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\urlstyle{same}

\newenvironment{level}%
{\addtolength{\itemindent}{2em}}%
{\addtolength{\itemindent}{-2em}}

\usepackage{amsmath,amsthm,amssymb}


\usepackage[x11names, rgb]{xcolor}
\usepackage{graphicx}
\usepackage[nooldvoltagedirection]{circuitikz}
\usetikzlibrary{decorations,arrows,shapes}

\usepackage{datetime}
\usepackage{etoolbox}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{array}
\usepackage{varwidth}
\usepackage{tcolorbox}
\usepackage{circuitikz}
\usepackage[linguistics]{forest}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{mystyle}{
    language=JavaScript,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
%%%%%%%%%%%%%%%%%%%%%%%% QUESTION # %%%%%%%%%%%%%%%%%%%%%%%%
%% You can ignore this for the most part. Basically it    %%
%% helps number your questions and creates a new page     %%
%% with each question for the aesthetics. It also creates %%
%% parts i.e. (a) (b) (c) for multiple part questions.    %%
%% To use do: \begin{question} ... \end{question}         %%
%% and: \begin{part} ... \end{part}                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}

\providetoggle{questionnumbers}
\settoggle{questionnumbers}{true}
\newcommand{\noquestionnumbers}{
    \settoggle{questionnumbers}{false}
}

\newcounter{questionCounter}
\newenvironment{question}[2][\arabic{questionCounter}]{%
    \ifnum\value{questionCounter}=0 \else {\newpage}\fi%
    \setcounter{partCounter}{0}%
    \vspace{.25in} \hrule \vspace{0.5em}%
    \noindent{\bf \iftoggle{questionnumbers}{Question #1: }{}#2}%
    \addtocounter{questionCounter}{1}%
    \vspace{0.8em} \hrule \vspace{.10in}%
}

\newcounter{partCounter}[questionCounter]
\renewenvironment{part}[1][\alph{partCounter}]{%
    \addtocounter{partCounter}{1}%
    \vspace{.10in}%
    \begin{indented}%
       {\bf (#1)} %
}{\end{indented}}

\def\indented#1{\list{}{}\item[]}
\let\indented=\endlist
\def\show#1{\ifdefempty{#1}{}{#1\\}}

%%%%%%%%%%%%%%%%%%%%%%%% SHORT CUTS %%%%%%%%%%%%%%%%%%%%%%%%
%% This is just to improve your quality of life. Instead  %%
%% of having to type long things, you can type short      %%
%% things. Ex: \IMP instead of \rightarrow to get ->      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\IMP{\rightarrow}
\def\AND{\wedge}
\def\OR{\vee}
\def\BI{\leftrightarrow}
\def\DIFF{\setminus}
\def\SUB{\subseteq}

\newcolumntype{C}{>{\centering\arraybackslash}m{1.5cm}}
\renewcommand\qedsymbol{$\blacksquare$}

%%%%%%%%%%%%%%%%%%%%%%%% ANSWER BOX %%%%%%%%%%%%%%%%%%%%%%%%
%% This will improve the quality of life for your TA.     %%
%% Use \begin{answer} and \end{answer} to surround your   %%
%% answers so it will be easier to see. You can adjust    %%
%% the background and frame colors below as needed.       %%
%% Here is the manual to help: tinyurl.com/tcolorbox-man  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtcolorbox{answer}
{
  colback   = green!5!white,    % Background color
  colframe  = green!75!black,   % Outline color
  box align = center,           % Align box on text line
  varwidth upper,               % Enables multi line input
  hbox                          % Bounds box to text width
}

%%%%%%%%%%%%%%%%% Identifying Information %%%%%%%%%%%%%%%%%
%% For 311, we'd rather you DIDN'T tell us who you are   %%
%% in your homework so that we're not biased when        %%
%% So, even if you fill this information in, it will not %%
%% show up in the document unless you uncomment \header  %%
%% below                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\myhwname}{Homework 1}
\newcommand{\myname}{Sebastian Liu}
\newcommand{\myemail}{ll57@cs.washington.edu}
\newcommand{\mysection}{AD}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%% Document Options %%%%%%%%%%%%%%%%%%%%%%
\noquestionnumbers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%% WORK BELOW %%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{center}
    \textbf{Homework 1 Written} \bigskip
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 1 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{1. The Level Is in the Details (10 points)}
   \begin{part}
        \begin{answer}
            \textbf{Correctness Level:} -1

            \textbf{Explanation:} Since the function is defined on pair of colors where each color is either red, green, or blue, 
            so we have $2 \cdot 3 = 6$ total possible inputs. Because we can use exhaustive testing on the small number of inputs, 
            the function requires a correctness level of -1.

        \end{answer}
   \end{part}
   
   \begin{part}
        \begin{answer}
            \textbf{Correctness Level:} 0

            \textbf{Explanation:} There are infinitely many inputs. Because the function only contains a single returning statement 
            and the calculation inside the function is described by the mathematical function straight from the specification, the 
            function translate the behavior straight from the spec requires a correctness level of 0.
        \end{answer}
   \end{part}

   \begin{part}
        \begin{answer}
            It falls into level 3 of correctness. Since we have infinitely many inputs and a declarative specification, the correctness
             level cannot be -1 or 0. Because we do not know what level of mutation the function has, we have to take into account the 
             most complex case possible (array/object mutation). Therefore, the program falls into level 3 of correctness.
        \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}
            It fits into level 2 of correctness. Since we have infinitely many inputs and a declarative specification, the correctness
            level cannot be -1 or 0. Because we have local variable mutation but not heap-allocated data mutation (a.k.a. array/object mutation),
            the program fits into level 2 of correctness.
        \end{answer}
    \end{part}

    \newpage

    \begin{part}
        \begin{answer}
            It's not ok to assume that the first problem has a lower correctness level, because the correctness level depends on whether the
            specification describes the calculation or not (i.e. is non-declarative or not). If both specifications are declarative, meaning we
            cannot translate our program straight from the specification, both problems require 1-3 level of correctness depending on their implementations.
            The length of the specification doesn't necessarily affect the level of correctness.
        \end{answer}
    \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 2 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{2. Test Friend Forever (12 points)}
    \begin{part}
        \begin{lstlisting}
            function f(a : number, b : boolean) : [number, boolean] {
                const num : number = 2 * a;
                const bool : boolean = true;

                return [num, bool];
            }
        \end{lstlisting}
    \end{part}   

    \begin{part}
        \begin{answer}
            Given that we don't know the implementation of the program, we need to use opaque-box testing and come up with test cases base on the information
            we have about the input and output (both are lists of integers). I would argue we need at least three tests to have some level of confidence that
            the program is correct to some extent. The three test inputs could be: 1. an empty list (i.e. special cases for a list), 2. an arbitrarily-sized 
            list of negative integers (i.e. one subdomain of integers), 3. an list of non-negative integers with a different size (i.e. the other 
            subdomain of integers).\\

            However, only using opaque-box testing is usually not enough, to have a better level confidence on the correctness of the program, we need to look
            at the implementation of the program and use clear-box testing. 
        \end{answer}
    \end{part}   
 
    \begin{part}
        \begin{answer}
            Because replacing the expression might change the boundary/edge cases, the subdomains, the number of branches, or the number of recursive calls,
            which will affect of the effectiveness of our original test inputs (i.e. the old test inputs might not cover the subdomains and boundaries 
            of the new expression). Therefore, when we replace the expression we might need to re-evaluate the implementation of the new expression 
            and pick test inputs that covers all the subdomains of the new code. \\
            
            For example, if the original expression was "if ($x > 0$) \{ return 1 \} else \{return 0\}", a set of valid test inputs could be \{1, 10, 0, -1\}.
            If we were to change the expression to be "if ($x > 100$) \{ return 1 \} else \{return 0\}", we need to change the inputs to something like 
            \{101, 110, 100, 99\} because the old input doesn't cover the boundary cases of the new expression which are 100, 99, 101. 
        \end{answer}
    \end{part} 

    \newpage

    \begin{part}
        \begin{answer}
            We might want to add more tests when we replace a non-recursive function call with a recursive function call, or when we replace a function call
            that doesn't have hidden branches with a function that has hidden branches. We generally treat function calls as straight-line code that needs
            two test cases, but when a function call is recursive or has hidden branches, we need to add additional test cases to test the additional subdomains the 
            recursive call or the hidden conditional introduces.
        \end{answer}
    \end{part}   

    \begin{part}
        \begin{answer}
            Generally, the changes that don't involve any changes in the subdomains of the inputs and outputs would not require changing any test inputs. For example, 
            if we change "if ($x > 5$) \{ return x + 1 \} else \{return x + 2\}" to "if ($x > 5$) \{ return x - 1 \} else \{return x - 2\}", it would be ok if we don't
            change any test inputs, because the two branches in the conditional are the same before and after the change.
        \end{answer}
    \end{part}   

    \begin{part}
        \begin{answer}
            We may need to change the expected outputs in all three cases. For (c) and (d), we may need to change outputs because we might need to change the inputs or 
            add more tests which will introduce different outputs. For (e), we may need to change the expected outputs because we might change the underlying calculation
            of the function, which would produce different outputs even though we have the same input (like my example in part (e)).
        \end{answer}
    \end{part}   
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 4 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{4. Good, Better, Test (18 points)}
    \begin{part}
        \begin{answer}
           \textbf{Number of tests:} We would need 4 test cases.\\
            \textbf{Explanation: } In the code, we have 4 branches each corresponds to one possible inputs (4 possible inputs in total) and contains a straight line calculation
                                   that returns a constant. Since we only have a small number of inputs, we should do an exhaustive testing (tests all 4 possible inputs).  \\
            \textbf{Example set: } \begin{align*} &case1: color = "red" &&case3: color = "blue"\\ &case2: color = "green" &&case4: color = undefined \end{align*}
            \textbf{Reasoning: } case1 tests the red branch, case2 tests the green branch, case3 tests the blue branch, and case4 tests the default branch. According to the
                                 clear-box testing rules, since we have 4 branches and each branch has a straight line calculation, we are supposed to have 2 tests for each branch
                                 making it 8 tests in total. However, we only have one possible input for each subdomain, so we only need 4 tests in total to cover all subdomains.
                                 Also, because we have a small number of inputs which makes this function require level -1 of correctness, in which case, we need to test all
                                 4 possible inputs.
        \end{answer}
    \end{part}   
 
    \begin{part}
        \begin{answer}
            \textbf{Number of tests:} We would need 6 test cases.\\
            \textbf{Explanation: } In the code, we have 3 branches each corresponds to one possible color input and contains a straight line calculation. 
                                  Since each branch needs 2 tests, we need 6 test cases in total.  \\
            \textbf{Example set: } \begin{align*}
                &case1: color = "red", x = -54 &&case4: color = "green", x = -23\\ &case2: color = "red", x = 32; &&case5: color = "blue", x = 64\\ &case3: color = "green", x = 82 &&case6: color = "blue", x = -47 
            \end{align*}
            \textbf{Reasoning: } case1 and case2 test the red branch to see if x is returned consistently; case3 and case4 tests the green branch to see if both -x is returned consistently; case5 and case6 test the blue branch and see if 0 is returned consistently. 
                                 According to the clear-box testing rules, since we have 3 branches and each branch has a straight line calculation, we need to have 2 tests for each branch making it 6 tests in total.
        \end{answer}
    \end{part} 

    \newpage

    \begin{part}
        \begin{answer}
            \textbf{Number of tests: } We would need 9 test cases. \\
            \textbf{Explanation: } In the code, we have 6 hidden branches from two calls of f2. Each function call to f2 contains 3 branches. Since the number passed into
                                   f2 are fixed, we only have $3 \cdot 3 = 9$ possible combination of color inputs. Since each hidden subdomains contains a straight line 
                                   calculation that returns a constant and we only have a small number of inputs, we should do an exhaustive testing (test all 9 possible inputs).  \\
            \textbf{Example set: } \begin{align*}&case1: color1 = "red", color2 = "red" &&case6: color1 = "green", color2 = "blue"\\ 
                                                &case2: color1 = "red", color2 = "green" &&case7: color1 = "blue", color2 = "red" \\ 
                                                &case3: color1 = "red", color2 = "blue" &&case8: color1 = "blue", color2 = "green" \\
                                                &case4: color1 = "green", color2 = "red" &&case9: color1 = "blue", color2 = "blue"\\ 
                                                &case5: color1 = "green", color2 = "green" 
                                 \end{align*}
            \textbf{Reasoning: } case1 tests the red-red combination, case2 tests the red-green combination, case3 tests the red-blue combination, case4 tests the green-red combination, and so on. 
                                 Because we have a small number of inputs (9 possible inputs in total) which makes this function require level -1 of correctness, in which case, we need to test all
                                 9 possible inputs.
        \end{answer}
    \end{part}   

    \begin{part}
        \begin{answer}
            \textbf{Number of tests: } We would need 3 test cases. \\
            \textbf{Explanation: } The recursive function has 1 base case and 1 recursive case. There's only one possible test for the base case, and we need two tests for the recursive case, making it
                                    3 tests in total.  \\
            \textbf{Example set: } \begin{align*}&case1: A = [] &&case3: A = [34, -12, 0]\\ 
                                                &case2: A = [25]
                                 \end{align*}
            \textbf{Reasoning: } Following the "0-1-many" heuristic for testing recursive functions, case1 tests base case, case2 tests recursively calling the base case, case3 tests recursively calling
                                the recursive call. 
                                 
        \end{answer}
    \end{part}   

    \newpage
    \begin{part}
        \begin{answer}
            \textbf{Number of tests: } We would need 4 test cases. \\
            \textbf{Explanation: } The recursive function has 1 base case and 1 recursive case. We need two tests for base case and two for the recursive case, making it
                                    4 tests in total.  \\
            \textbf{Example set: } \begin{align*}&case1: n = -1 &&case3: n = 1\\ 
                                                &case2: n = 0 &&case4: n = 2
                                 \end{align*}
            \textbf{Reasoning: } Following the "0-1-many" heuristic for testing recursive functions, case1 and case2 test base case, case3 tests recursively calling the base case, case4 tests recursively calling
                                the recursive call. 
        \end{answer}
    \end{part}   

    \begin{part}
        \begin{answer}
            \textbf{Number of tests: } We would need 7 test cases. \\
            \textbf{Explanation: } The recursive function has 1 base case and 3 recursive cases. There's only one possible test for the base case, and we need two tests for the recursive case, making it
                                  $1 + 2 \cdot 3 = 7$ tests in total. \\
            \textbf{Example set: } \begin{align*}&case1: n = 0 &&case5: n = 7\\ 
                                                &case2: n = 3 &&case6: n = 5 \\
                                                &case3: n = 6 &&case7: n = 8 \\
                                                &case4: n = 4 
                                 \end{align*}
            \textbf{Reasoning: } Following the "0-1-many" heuristic for testing recursive functions, case1 tests the base case, case3 and case4 test the first recursive case, case4 and case5 test the second recursive case, 
                                 and case6 and case7 test the third recursive case.
        \end{answer}
    \end{part}   

\end{question}

\end{document}
