%%%%%%%%%%%%%%%%%%%%% PACKAGE IMPORTS %%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt]{article}
\usepackage{amsmath, amsfonts, amsthm, amssymb}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{fullpage}       
\usepackage{changepage}
\usepackage{hyperref}
\usepackage{blindtext}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\urlstyle{same}

\newenvironment{level}%
{\addtolength{\itemindent}{2em}}%
{\addtolength{\itemindent}{-2em}}

\usepackage{amsmath,amsthm,amssymb}


\usepackage[x11names, rgb]{xcolor}
\usepackage{graphicx}
\usepackage[nooldvoltagedirection]{circuitikz}
\usetikzlibrary{decorations,arrows,shapes}

\usepackage{datetime}
\usepackage{etoolbox}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{array}
\usepackage{varwidth}
\usepackage{tcolorbox}
\usepackage{circuitikz}
\usepackage[linguistics]{forest}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{mystyle}{
    language=JavaScript,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
%%%%%%%%%%%%%%%%%%%%%%%% QUESTION # %%%%%%%%%%%%%%%%%%%%%%%%
%% You can ignore this for the most part. Basically it    %%
%% helps number your questions and creates a new page     %%
%% with each question for the aesthetics. It also creates %%
%% parts i.e. (a) (b) (c) for multiple part questions.    %%
%% To use do: \begin{question} ... \end{question}         %%
%% and: \begin{part} ... \end{part}                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}

\providetoggle{questionnumbers}
\settoggle{questionnumbers}{true}
\newcommand{\noquestionnumbers}{
    \settoggle{questionnumbers}{false}
}

\newcounter{questionCounter}
\newenvironment{question}[2][\arabic{questionCounter}]{%
    \ifnum\value{questionCounter}=0 \else {\newpage}\fi%
    \setcounter{partCounter}{0}%
    \vspace{.25in} \hrule \vspace{0.5em}%
    \noindent{\bf \iftoggle{questionnumbers}{Question #1: }{}#2}%
    \addtocounter{questionCounter}{1}%
    \vspace{0.8em} \hrule \vspace{.10in}%
}

\newcounter{partCounter}[questionCounter]
\renewenvironment{part}[1][\alph{partCounter}]{%
    \addtocounter{partCounter}{1}%
    \vspace{.10in}%
    \begin{indented}%
       {\bf (#1)} %
}{\end{indented}}

\def\indented#1{\list{}{}\item[]}
\let\indented=\endlist
\def\show#1{\ifdefempty{#1}{}{#1\\}}

%%%%%%%%%%%%%%%%%%%%%%%% SHORT CUTS %%%%%%%%%%%%%%%%%%%%%%%%
%% This is just to improve your quality of life. Instead  %%
%% of having to type long things, you can type short      %%
%% things. Ex: \IMP instead of \rightarrow to get ->      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\IMP{\rightarrow}
\def\AND{\wedge}
\def\OR{\vee}
\def\BI{\leftrightarrow}
\def\DIFF{\setminus}
\def\SUB{\subseteq}

\newcolumntype{C}{>{\centering\arraybackslash}m{1.5cm}}
\renewcommand\qedsymbol{$\blacksquare$}

%%%%%%%%%%%%%%%%%%%%%%%% ANSWER BOX %%%%%%%%%%%%%%%%%%%%%%%%
%% This will improve the quality of life for your TA.     %%
%% Use \begin{answer} and \end{answer} to surround your   %%
%% answers so it will be easier to see. You can adjust    %%
%% the background and frame colors below as needed.       %%
%% Here is the manual to help: tinyurl.com/tcolorbox-man  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtcolorbox{answer}
{
  colback   = green!5!white,    % Background color
  colframe  = green!75!black,   % Outline color
  box align = center,           % Align box on text line
  varwidth upper,               % Enables multi line input
  hbox                          % Bounds box to text width
}

%%%%%%%%%%%%%%%%% Identifying Information %%%%%%%%%%%%%%%%%
%% For 311, we'd rather you DIDN'T tell us who you are   %%
%% in your homework so that we're not biased when        %%
%% So, even if you fill this information in, it will not %%
%% show up in the document unless you uncomment \header  %%
%% below                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\myhwname}{Homework 3}
\newcommand{\myname}{Sebastian Liu}
\newcommand{\myemail}{ll57@cs.washington.edu}
\newcommand{\mysection}{AD}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%% Document Options %%%%%%%%%%%%%%%%%%%%%%
\noquestionnumbers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%% WORK BELOW %%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{center}
    \textbf{Homework 3 Written} \bigskip
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 1 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{1. Apple Cipher (13 points)}
   \begin{part}
        \begin{answer}
            \begin{align*}
                \textbf{func\;\;} &cipher\_encode(nil) &&:= nil \\
                & cipher\_encode(cons(c, L_c)) &&:= cons(nc(c), cipher\_encode(L_c)) \tag{for any $c : Character$ and $L_c : List_c$}  
            \end{align*}

            \begin{align*}
                \textbf{func\;\;} &cipher\_decode(nil) &&:= nil \\
                &cipher\_decode(cons(c, L_c)) &&:= cons(pc(c), cipher\_decode(L_c)) \tag{for any $c : Character$ and $L_c : List_c$}  
            \end{align*}
        \end{answer}
    \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 2 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{2. Whoopsie-Crazy (13 points)}
    \begin{part}
        \begin{answer}
            \begin{align*}
                \textbf{func\;\;} &crazy\_caps\_encode(nil) &&:= nil \\
                &crazy\_caps\_encode(cons(c, L_c)) &&:= cons(up(c), crazy\_caps\_encode\_helper(L_c)) \tag{for any $c : Character$ and $L_c : List_c$}
            \end{align*}

            \begin{align*}
                \textbf{func\;\;} &crazy\_caps\_encode\_helper(nil) &&:= nil \\
                &crazy\_caps\_encode\_helper(cons(c, L_c)) &&:= cons(c, crazy\_caps\_encode(L_c)) \tag{for any $c : Character$ and $L_c : List_c$}  
            \end{align*}

            \begin{align*}
                \textbf{func\;\;} &crazy\_caps\_decode(nil) &&:= nil \\
                &crazy\_caps\_decode(cons(c, L_c)) &&:= cons(lc(c), crazy\_caps\_decode\_helper(L_c)) \tag{for any $c : Character$ and $L_c : List_c$}  
            \end{align*}

            \begin{align*}
                \textbf{func\;\;} &crazy\_caps\_decode\_helper(nil) &&:= nil \\
                &crazy\_caps\_decode\_helper(cons(c, L_c)) &&:= cons(c, crazy\_caps\_decode(L_c)) \tag{for any $c : Character$ and $L_c : List_c$} 
            \end{align*}
        \end{answer}
    \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 3 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{3. Have Your Take and Eat It Too (15 points)}
    \begin{part}
        \begin{answer}
            Let $P(S)$ be the claim "$take(echo(S)) = S for any S : List$". \\
            We show $P(S)$ holds for any list $L \in S$ by structural induction.\\
            \textbf{Base Case (S = nil):} 
            \begin{align*}
                take(echo(nil)) &= take(nil) \tag{Def of $echo$} \\
                &= nil \tag{Def of $take$}
            \end{align*}
            \textbf{Inductive Hypothesis:} Suppose $P(L)$ holds for a list $L$ \\
            \textbf{Inductive Step ($P(cons(a, L))$):} Let $a$ be an arbitrary integer.
            \begin{align*}
                take(echo(cons(a, L))) &= take(cons(a, cons(a, echo(L)))) \tag{Def of $echo$}\\
                &= cons(a, skip(cons(a, echo(L)))) \tag{Def of $take$} \\
                &= cons(a, take(echo(L))) \tag{Def of $skip$}\\
                &= cons(a, L) \tag{Inductive Hypothesis}
            \end{align*}

            \textbf{Conclusion:} Therefore, $P(S)$ holds for any list $S$ by the principle of induction.
        \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}
            \begin{align*}
                take(cons(1, cons(2, echo(L)))) &= cons(1, skip(cons(2, echo(L)))) \tag{Def of $take$}\\
                &= cons(1, take(echo(L))) \tag{Def of $skip$} \\
                &= cons(1, L) \tag{From part(a): $take(echo(S))=S$} 
            \end{align*}
        \end{answer}
    \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 4 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{4. Five, Fix, Seven, Eight (14 points)}
    \begin{part}
        \begin{answer}
            \begin{align*}
                \textbf{func\;\;} &prefix(n, L) &&:= undefined \tag{if $n > len(L)$ } \\
                &prefix(0, L) &&:= nil \tag{for any $L : List$} \\
                &prefix(n + 1, cons(x, L)) &&:= cons(x, prefix(n, L)) \tag{for any $n : \mathbb{N}$, $x : \mathbb{Z}$, and $L : List$}
            \end{align*}

            \begin{align*}
                \textbf{func\;\;} &suffix(n, L) &&:= undefined \tag{if $n > len(L)$ } \\
                &suffix(0, L) &&:= L \tag{for any $L : List$} \\
                &suffix(n + 1, cons(x, L)) &&:= suffix(n, L) \tag{for any $n : \mathbb{N}$, $x : \mathbb{Z}$, and $L : List$}
            \end{align*}
        \end{answer}
    \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 5 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{5. Living in the Last (25 points)}
    \begin{part}
        \begin{answer}
            Let $L$ be an arbitrary List.\\
            By the definition of List, we divide into two cases.\\
            \textbf{Case 1: } $L = nil$. 
            \begin{align*}
                concat(L, cons(b, nil)) &= concat(nil, cons(b, nil)) \tag{Def of $L$}\\
                &= cons(b, nil) \tag{Def of $concat$} \\
                &\ne nil \tag{Since $b : \mathbb{Z}$, Def of $cons$}
            \end{align*}
            \textbf{Case 2: } $L = cons(a, R)$ for some $a : \mathbb{Z}$ and $R : List$
            \begin{align*}
                concat(L, cons(b, nil)) &= concat(cons(a, R), cons(b, nil)) \tag{Def of $L$}\\
                &= cons(a, concat(R, cons(b, nil))) \tag{Def of $concat$} \\
                &\ne nil \tag{Since $a : \mathbb{Z}$,  Def of $cons$}
            \end{align*}
            In either case, $concat(L, cons(b, nil)) \ne nil$. Since an arbitrary $L$ is a List, by the definition of List, we know the claim $concat(L, cons(b, nil))$ holds for all Lists.
        \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}
            Let $P(S)$ be the claim "$last(concat(S, cons(b, nil))) = b for any b : \mathbb{Z} and any S: List$". \\
            We show $P(S)$ holds for any list $L \in S$ by structural induction.\\
            \textbf{Base Case (S = nil):} 
            \begin{align*}
                last(concat(nil, cons(b, nil))) &= last(cons(b, nil)) \tag{Def of $concat$} \\
                &= b \tag{Def of $last$}
            \end{align*}
            \textbf{Inductive Hypothesis:} Suppose $P(L)$ holds for a list $L$ \\
            \textbf{Inductive Step ($P(cons(a, L))$):} Let $a$ be an arbitrary integer.
            \begin{align*}
                last(concat(cons(a, L), cons(b, nil))) &= last(cons(a, concat(L, cons(b, nil)))) \tag{Def of $concat$}\\
                &= last(concat(L, cons(b, nil))) \tag{Def of $last$, and $concat(L, cons(b, nil)) \ne nil$ from part(a)} \\ \\
                &= b \tag{Inductive Hypothesis}
            \end{align*}

            \textbf{Conclusion:} Therefore, $P(S)$ holds for any list $S$ by the principle of induction.

        \end{answer}
    \end{part}
\newpage
    \begin{part}
        \begin{answer}
            \begin{align*}
                last(rev(cons(a, R))) &= last(concat(rev(R), cons(a, nil))) \tag{Def of rev} \\
                &= a \tag{$last(concat(S, cons(b, nil))) = b$ from part(b)}
            \end{align*}

        \end{answer}
    \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 6 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{6. Extra Credit: Vowel Movement (0 points)}
    \begin{part}
        \begin{answer}
            \begin{align*}
                \textbf{func\;\;} 
                &pig\_latin\_encode(L) := L \tag{for any $L : List$ where $cc(L) = -1$ or $cc(L) =$ undefined} \\
                &pig\_latin\_encode(L) := concat(L, explode("way")) \tag{for any $L : List$ where $cc(L) = 0$}\\\\
                &pig\_latin\_encode(L) := concat(suffix(cc(L), L), concat(prefix(cc(L), L), explode("ay"))) \\ &\text{(for any $L : List$ where $cc(L) \ge 1$ and $last(prefix(cc(L), L)) \ne char("q")$ or} \\ &\text{$ hd(suffix(cc(L), L)) \ne char("u")$ or $cc(suffix(1, suffix(cc(L)), L) \ne 0)$}\\\\
                &pig\_latin\_encode(L) := concat(suffix(cc(L) + 1, L), concat(prefix(cc(L) + 1, L), explode("ay"))) \\ &\text{(for any $L : List$ where $cc(L) \ge 1$ and $last(prefix(cc(L), L)) = char("q")$ and} \\ &\text{$ hd(suffix(cc(L), L)) = char("u")$ and $cc(suffix(1, suffix(cc(L)), L) = 0)$}
            \end{align*}

        \end{answer}
    \end{part}

    \begin{part}[d]
        \begin{answer}
            \begin{align*}
                \textbf{func\;\;} 
                &pig\_latin\_encode(L) := L \tag{for any $L : List$ where $compact(prefix(2, rev(L))) \ne "ya"$} \\\\
                &pig\_latin\_encode(L) := L  \tag{for any $L : List$ where $cc(suffix(2, rev(L))) \le 0$} \\\\
                &pig\_latin\_encode(L) := prefix(len(L) - 3, L) \tag{for any $L : List$ where $compact(prefix(3, rev(L))) = "yaw"$ and $cc(suffix(3, rev(L))) = 0$} \\\\ 
                &pig\_latin\_encode(L) := concat(explode("qu"), prefix(len(L) - 4, L)) \tag{for any $L : List$ where $compact(prefix(4, rev(L))) = "yauq"$}\\\\
                &pig\_latin\_encode(L) := concat(prefix(len(suffix(len(L) - cc(suffix(2, rev(L))) + 2, L)) - 2, \\ 
                &suffix(len(L) - cc(suffix(2, rev(L))) + 2, L)), prefix(len(L) - cc(suffix(2, rev(L))) + 2, L)) \tag{for any $L : List$ where previous two cases do not apply and $cc(suffix(2, rev(L))) \ge 1$}
            \end{align*}
        \end{answer}
    \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Question# 7 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{8. Extra Credit: Roll the Twice (0 points)}
    \begin{answer}
        Proof for $skip(twice\_odds(L)) = twice(take(L))$


        Let $P(S)$ be the claim "$take(twice\_evens(S)) = twice(take(S))$ for any S: List". \\
            We show $P(S)$ holds for any list $L \in S$ by structural induction.\\
            \textbf{Base Case (S = nil):} 
            \begin{align*}
               take(twice\_evens(nil)) &= take(nil) \tag{Def of $twice\_evens$} \\
                &= nil \tag{Def of $take$} \\
                &= take(nil) \tag{Def of $takes$} \\
                &= twice(take(nil)) \tag{Def of $twice$ and since $take(nil) = nil$}
            \end{align*}
            \textbf{Inductive Hypothesis:} Suppose $P(L)$ holds for a list $L$ \\
            \textbf{Inductive Step ($P(cons(a, L))$):} Let $a$ be an arbitrary integer.
            \begin{align*}
                take(twice\_evens(cons(a, L))) &= take(cons(2a, twice\_odds(L))) \tag{Def of $twice\_evens$}\\
                &= cons(2a, skip(twice\_odds(L))) \tag{Def of $take$} \\
                &= cons(2a, twice(skip(L))) \\
                &= twice(cons(a, skip(L))) \\
                &= twice(take(cons(a, L)))
            \end{align*}
            \textbf{Conclusion:} Therefore, $P(S)$ holds for any list $S$ by the principle of induction.
    \end{answer}
    
\end{question}

\end{document}